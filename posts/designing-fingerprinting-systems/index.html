<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Designing Fingerprinting Systems | Revanth's blog</title><meta name=keywords content><meta name=description content="In online applications customer journey identification and conversion tracking are essential to grow any business. The customer journey starts with a customer reaching the landing page and browsing / engaging with the content before the customer makes a purchase/logs in. It is important to tie this anonymous behaviour with the existing customer behaviour to

personalize content like recommend products that are useful to the customer.
Understand if the landing page conversion to take an action like purchase are meaningful.
Identify and filter out bots from customer behavioural data.

Below is a simple and quick fingerprinting system design."><meta name=author content="Revanth Pentyala"><link rel=canonical href=https://revanthp.github.io/posts/designing-fingerprinting-systems/><link crossorigin=anonymous href=https://revanthp.github.io/assets/css/stylesheet.a8501b4e1544bf104a4e2647be64df3637f95b6ac25a4298047d87fe0eacffa1.css integrity="sha256-qFAbThVEvxBKTiZHvmTfNjf5W2rCWkKYBH2H/g6s/6E=" rel="preload stylesheet" as=style><link rel=icon href=https://revanthp.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://revanthp.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://revanthp.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://revanthp.github.io/apple-touch-icon.png><link rel=mask-icon href=https://revanthp.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://revanthp.github.io/posts/designing-fingerprinting-systems/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://cdn.jsdelivr.net crossorigin><link rel=preconnect href=https://gc.zgo.at crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=preload as=style href=https://revanthp.github.io/scss/custom.min.be36c2cbcca2bc0d647f885b04906b79936d2b044488b50ddc981645f22dc584.css onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://revanthp.github.io/scss/custom.min.be36c2cbcca2bc0d647f885b04906b79936d2b044488b50ddc981645f22dc584.css></noscript><script defer src=https://revanthp.github.io/js/performance.min.eab2011b5e402f6423e6f864df14369b701f1b07719273a0c43d5b082b8ac680.js></script><style>.critical-content{font-display:swap}img{height:auto;max-width:100%}#theme-toggle{will-change:transform}@media(prefers-reduced-motion:reduce){*,*::before,*::after{animation-duration:.01ms !important;animation-iteration-count:1 !important;transition-duration:.01ms !important}}</style><link rel=preload as=style href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css></noscript><script defer data-goatcounter=https://fawkes2014.goatcounter.com/count src=https://gc.zgo.at/count.js></script><link rel=dns-prefetch href=//www.google-analytics.com><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=X-Content-Type-Options content="nosniff"><meta http-equiv=Referrer-Policy content="strict-origin-when-cross-origin"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=dns-prefetch href=//cdn.jsdelivr.net><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><meta http-equiv=Referrer-Policy content="strict-origin-when-cross-origin"><meta http-equiv=X-Content-Type-Options content="nosniff"><meta http-equiv=X-XSS-Protection content="1; mode=block"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><meta property="og:title" content="Designing Fingerprinting Systems"><meta property="og:description" content="In online applications customer journey identification and conversion tracking are essential to grow any business. The customer journey starts with a customer reaching the landing page and browsing / engaging with the content before the customer makes a purchase/logs in. It is important to tie this anonymous behaviour with the existing customer behaviour to

personalize content like recommend products that are useful to the customer.
Understand if the landing page conversion to take an action like purchase are meaningful.
Identify and filter out bots from customer behavioural data.

Below is a simple and quick fingerprinting system design."><meta property="og:type" content="article"><meta property="og:url" content="https://revanthp.github.io/posts/designing-fingerprinting-systems/"><meta property="og:image" content="https://revanthp.github.io/favicon.ico"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-29T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-03T15:27:54-08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://revanthp.github.io/favicon.ico"><meta name=twitter:title content="Designing Fingerprinting Systems"><meta name=twitter:description content="In online applications customer journey identification and conversion tracking are essential to grow any business. The customer journey starts with a customer reaching the landing page and browsing / engaging with the content before the customer makes a purchase/logs in. It is important to tie this anonymous behaviour with the existing customer behaviour to

personalize content like recommend products that are useful to the customer.
Understand if the landing page conversion to take an action like purchase are meaningful.
Identify and filter out bots from customer behavioural data.

Below is a simple and quick fingerprinting system design."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"\"Posts\"","item":"\"https://revanthp.github.io/posts/\""},{"@type":"ListItem","position":2,"name":"\"Designing Fingerprinting Systems\"","item":"\"https://revanthp.github.io/posts/designing-fingerprinting-systems/\""}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"\"Designing Fingerprinting Systems\"","name":"\"Designing Fingerprinting Systems\"","description":"\"In online applications customer journey identification and conversion tracking are essential to grow any business. The customer journey starts with a customer reaching the landing page and browsing / engaging with the content before the customer makes a purchase/logs in. It is important to tie this anonymous behaviour with the existing customer behaviour to\\npersonalize content like recommend products that are useful to the customer. Understand if the landing page conversion to take an action like purchase are meaningful. Identify and filter out bots from customer behavioural data. Below is a simple and quick fingerprinting system design.\\n\"","keywords":[],"articleBody":"\"In online applications customer journey identification and conversion tracking are essential to grow any business. The customer journey starts with a customer reaching the landing page and browsing / engaging with the content before the customer makes a purchase/logs in. It is important to tie this anonymous behaviour with the existing customer behaviour to\\npersonalize content like recommend products that are useful to the customer. Understand if the landing page conversion to take an action like purchase are meaningful. Identify and filter out bots from customer behavioural data. Below is a simple and quick fingerprinting system design.\\nDefinitions: Even though we are calling session level data, it is actually event payload and cookie information.\\nSetup Let us start with an internal customer-session database. We will use the session information as a unique idenfier for every single user session on the online application. This gives us a one-to-many mapping. Each customer_id can be mapped to multiple session_ids. Each session can be characterized by data from the browser, clicks, etc.\\nGoals We want to build a system that classifies a given session id to an existing group of customer ids or identify it as a new customer. It is okay to classify two sessions that belong to a customer id as two differnt customers. But we do not want to 2 customer_ids to be mapped to the same cutomer id.\\nSystem requirements:\\n100K user base Online user fingerprinting system latency 20 msec. Problem Formulation There are a couple of ways we can formulate this solution, let us go thorugh one by one.\\nMulti-class Classification: We could say each customer_id is one class and train an algorithm on this data to predict the class the session_id belong to. This approach has a few drawbacks:\\nWe would have huge number of classes to begin with, in the order of 100K customers to begin with and number of records per session would be very sparse around 10 or so on an average resulting in highly sparse dataset - we would run into the curse of dimensionality early on. With every new customer, we would have to constantly be training every day or every few hours to update the classes. This is not a very scalabe system. Clustering: We could use an algorithm like Kmeans or DBSCAN or some other algrithm. With this we will be able to map existing customers but new customers with multiple sessions run into challenges where we would have to retrain the algorithm with updating training set very frequently.\\nEmbedding based Proximity Search: The main idea here is that session information of a customer are closer in a higher dimensional space compared to a session from a different customers. Now the goal is to learn the higher dimensional space vector representation and distance threshold to identify sessions from the same customer to different customers. This has the following advantages:\\nCustomer level data sparsity: This is not an issue during inference since we are just mapping from higher dimension sparse vector space to a lower dimension dense vector representation.\\nNew customer identification: A new customer will have higher distance from neighboring sessions compared to sessions belonging to the same customer. This comes from the problem formulation itself.\\nML System Design Stage 1/2: Embedding System Design: The goal here is to ensure that the vector representation of the session_id has to be closer for sessions for the same customer but farther for sessions from different customers. This is a solved problem and used frequently in facial recognition. We can use triplet loss function which returns lower distance for sessions that belong to the same customer and greater distance for sessions that belong to different customers. The triplet loss function is defined as below.\\nLoss=max(0,d(a,p)−d(a,n)+α) Loss = max(0, d(a, p)-d(a, n)+\\\\alpha) Loss=max(0,d(a,p)−d(a,n)+α)Where,\\nd - distance metric\\na - anchor sample\\np - positive sample\\nn - negative sample\\nalpha - Margin\\nStage 2/2: Classifier threshold Now that we have the embeddings for any incoming session, we just need to calcuate the cosine distance between any two records to classify them as belong to the same customer or different customers. We can select this threshold as a heuristic that maximizes the evaluation metric. This can be tuned by using a Receiver Operating Characteristic (ROC) curve.\\nPutting it all together Evaluation:\\nOverall Evaluation Metric: Macro Precision\\nTrue Positive (TP): sessions belonging to the correct customer_id\\nTrue Negative (TN): single session for a new customer.\\nFalse Positive (FP): single session mapped to wrong customer_id\\nFalse Negative (FN): session belonging to a customer (with multiple sessions) mapped to new customer.\\nGiven that we have 50 metrics with categorical columns containing 2-3 categories in each, we can assume we will have roughly about 100 - 150 one hot encoded columns. We can now train a neural network that takes these as input columns and returns an embedding of size sqrt of 100 to sqrt 150, so roughly an embedding of 10 - 13. We will consider the embeddding size as a hyper-paramter to tune.\\nNeural Network Setup:\\ninput nodes: 100-150\\noutput nodes: 10-12\\nhidden layers: 2, 3, 4\\nLoss function for training neural network: Triplet loss with cosine distance\\nAdd a normalization layer before cosine computation.\\nHyperparatmers to tune:\\nhidden layers: 2, 3, 4\\noutput nodes: 10, 11, 12\\ndropout: 10, 20, 30\\nTriplet loss alpha: 0.2, 0.3, 0.5, 0.7\\nDataset:\\nTraining dataset size:\\n12K unique customers with 10 records each at minimum. More sessions per customer the better. Uniform distribution across device types (iOS vs Android), brower types (Safari vs Firefox vs Chrome) Filter records from Browers and devices that are currently supported and not deprecated anytime soon. This ensures that the patterns learnt are consistent with what is seen today. 1K customers with 10 records each chosen for validation dataset from training. We need ensure that the distribution between training and validation is consistent. Test set:\\n1K customers with 10 records each chosen for validation dataset from training. We need ensure that the distribution between training and test is consistent. Computing and looking up cosine distance across 100K - 1M records each time will be expensive and unnecessary. Instead we can simply use efficient implementation of this using Hierarchical Navigable Small World (HNSW) for Approximate Nearest neighbor seach. An efficient implementation of this can be found in FAISS python library (from Meta).\\n\"","wordCount":"1055","inLanguage":"\"en\"","image":"\"https://revanthp.github.io/favicon.ico\"","datePublished":"\"2025-11-29T00:00:00Z\"","dateModified":"\"2025-12-03T15:27:54-08:00\"","author":{"@type":"Person","name":"\"Revanth Pentyala\"","url":"\"https://www.linkedin.com/in/revanthpentyala/\""},"mainEntityOfPage":{"@type":"WebPage","@id":"\"https://revanthp.github.io/posts/designing-fingerprinting-systems/\""},"publisher":{"@type":"Organization","name":"\"Revanth's blog\"","logo":{"@type":"ImageObject","url":"\"https://revanthp.github.io/favicon.ico\""}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://revanthp.github.io/ accesskey=h title="Revanth's blog (Alt + H)">Revanth's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://revanthp.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://revanthp.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://revanthp.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://revanthp.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Designing Fingerprinting Systems</h1><div class=post-meta><span title='2025-11-29 00:00:00 +0000 UTC'>November 29, 2025</span>&nbsp;·&nbsp;Revanth Pentyala</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#stage-12-embedding-system-design>Stage 1/2: Embedding System Design:</a></li><li><a href=#stage-22-classifier-threshold>Stage 2/2: Classifier threshold</a></li><li><a href=#putting-it-all-together>Putting it all together</a></li></ul></nav></div></details></div><div class=post-content><p>In online applications customer journey identification and conversion tracking are essential to grow any business. The customer journey starts with a customer reaching the landing page and browsing / engaging with the content before the customer makes a purchase/logs in. It is important to tie this anonymous behaviour with the existing customer behaviour to</p><ol><li>personalize content like recommend products that are useful to the customer.</li><li>Understand if the landing page conversion to take an action like purchase are meaningful.</li><li>Identify and filter out bots from customer behavioural data.</li></ol><p>Below is a simple and quick fingerprinting system design.</p><h1 id=definitions>Definitions:<a hidden class=anchor aria-hidden=true href=#definitions>#</a></h1><p>Even though we are calling session level data, it is actually event payload and cookie information.</p><h1 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h1><p>Let us start with an internal customer-session database. We will use the session information as a unique idenfier for every single user session on the online application. This gives us a one-to-many mapping. Each customer_id can be mapped to multiple session_ids. Each session can be characterized by data from the browser, clicks, etc.</p><h1 id=goals>Goals<a hidden class=anchor aria-hidden=true href=#goals>#</a></h1><p>We want to build a system that classifies a given session id to an existing group of customer ids or identify it as a new customer.
It is okay to classify two sessions that belong to a customer id as two differnt customers. But we do not want to 2 customer_ids to be mapped to the same cutomer id.</p><p>System requirements:</p><ul><li>100K user base</li><li>Online user fingerprinting system</li><li>latency 20 msec.</li></ul><h1 id=problem-formulation>Problem Formulation<a hidden class=anchor aria-hidden=true href=#problem-formulation>#</a></h1><p>There are a couple of ways we can formulate this solution, let us go thorugh one by one.</p><p><strong>Multi-class Classification:</strong> We could say each customer_id is one class and train an algorithm on this data to predict the class the session_id belong to. This approach has a few drawbacks:</p><ul><li><ol><li>We would have huge number of classes to begin with, in the order of 100K customers to begin with and number of records per session would be very sparse around 10 or so on an average resulting in highly sparse dataset - we would run into the curse of dimensionality early on.</li></ol></li><li><ol start=2><li>With every new customer, we would have to constantly be training every day or every few hours to update the classes. This is not a very scalabe system.</li></ol></li></ul><p><strong>Clustering:</strong> We could use an algorithm like Kmeans or DBSCAN or some other algrithm. With this we will be able to map existing customers but new customers with multiple sessions run into challenges where we would have to retrain the algorithm with updating training set very frequently.</p><p><strong>Embedding based Proximity Search:</strong> The main idea here is that session information of a customer are closer in a higher dimensional space compared to a session from a different customers. Now the goal is to learn the higher dimensional space vector representation and distance threshold to identify sessions from the same customer to different customers. This has the following advantages:</p><p><em>Customer level data sparsity:</em> This is not an issue during inference since we are just mapping from higher dimension sparse vector space to a lower dimension dense vector representation.</p><p><em>New customer identification:</em> A new customer will have higher distance from neighboring sessions compared to sessions belonging to the same customer. This comes from the problem formulation itself.</p><h1 id=ml-system-design>ML System Design<a hidden class=anchor aria-hidden=true href=#ml-system-design>#</a></h1><h2 id=stage-12-embedding-system-design>Stage 1/2: Embedding System Design:<a hidden class=anchor aria-hidden=true href=#stage-12-embedding-system-design>#</a></h2><p>The goal here is to ensure that the vector representation of the session_id has to be closer for sessions for the same customer but farther for sessions from different customers. This is a solved problem and used frequently in facial recognition. We can use triplet loss function which returns lower distance for sessions that belong to the same customer and greater distance for sessions that belong to different customers. The triplet loss function is defined as below.</p><span class=katex-display><span class=katex><span class=katex-mathml><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
Loss = max(0, d(a, p)-d(a, n)+\alpha)
</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.6833em></span><span class="mord mathnormal">L</span><span class="mord mathnormal">oss</span><span class=mspace style=margin-right:.2778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class=mopen>(</span><span class=mord>0</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">d</span><span class=mopen>(</span><span class="mord mathnormal">a</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">p</span><span class=mclose>)</span><span class=mspace style=margin-right:.2222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal">d</span><span class=mopen>(</span><span class="mord mathnormal">a</span><span class=mpunct>,</span><span class=mspace style=margin-right:.1667em></span><span class="mord mathnormal">n</span><span class=mclose>)</span><span class=mspace style=margin-right:.2222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathnormal" style=margin-right:.0037em>α</span><span class=mclose>)</span></span></span></span></span><p>Where,</p><p>d - distance metric</p><p>a - anchor sample</p><p>p - positive sample</p><p>n - negative sample</p><p>alpha - Margin</p><h2 id=stage-22-classifier-threshold>Stage 2/2: Classifier threshold<a hidden class=anchor aria-hidden=true href=#stage-22-classifier-threshold>#</a></h2><p>Now that we have the embeddings for any incoming session, we just need to calcuate the cosine distance between any two records to classify them as belong to the same customer or different customers. We can select this threshold as a heuristic that maximizes the evaluation metric. This can be tuned by using a Receiver Operating Characteristic (ROC) curve.</p><h2 id=putting-it-all-together>Putting it all together<a hidden class=anchor aria-hidden=true href=#putting-it-all-together>#</a></h2><p><strong>Evaluation:</strong></p><p>Overall Evaluation Metric: Macro Precision</p><p>True Positive (TP): sessions belonging to the correct customer_id</p><p>True Negative (TN): single session for a new customer.</p><p>False Positive (FP): single session mapped to wrong customer_id</p><p>False Negative (FN): session belonging to a customer (with multiple sessions) mapped to new customer.</p><p>Given that we have 50 metrics with categorical columns containing 2-3 categories in each, we can assume we will have roughly about 100 - 150 one hot encoded columns. We can now train a neural network that takes these as input columns and returns an embedding of size sqrt of 100 to sqrt 150, so roughly an embedding of 10 - 13. We will consider the embeddding size as a hyper-paramter to tune.</p><p><strong>Neural Network Setup:</strong></p><p>input nodes: 100-150</p><p>output nodes: 10-12</p><p>hidden layers: 2, 3, 4</p><p>Loss function for training neural network: Triplet loss with cosine distance</p><p>Add a normalization layer before cosine computation.</p><p><strong>Hyperparatmers to tune:</strong></p><p>hidden layers: 2, 3, 4</p><p>output nodes: 10, 11, 12</p><p>dropout: 10, 20, 30</p><p>Triplet loss alpha: 0.2, 0.3, 0.5, 0.7</p><p><strong>Dataset:</strong></p><p>Training dataset size:</p><ul><li>12K unique customers with 10 records each at minimum. More sessions per customer the better.</li><li>Uniform distribution across device types (iOS vs Android), brower types (Safari vs Firefox vs Chrome)</li><li>Filter records from Browers and devices that are currently supported and not deprecated anytime soon. This ensures that the patterns learnt are consistent with what is seen today.</li><li>1K customers with 10 records each chosen for validation dataset from training. We need ensure that the distribution between training and validation is consistent.</li></ul><p>Test set:</p><ul><li>1K customers with 10 records each chosen for validation dataset from training. We need ensure that the distribution between training and test is consistent.</li></ul><p>Computing and looking up cosine distance across 100K - 1M records each time will be expensive and unnecessary. Instead we can simply use efficient implementation of this using Hierarchical Navigable Small World (HNSW) for Approximate Nearest neighbor seach. An efficient implementation of this can be found in FAISS python library (from Meta).</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://revanthp.github.io/>Revanth's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>